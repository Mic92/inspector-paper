\section{Introduction}
\label{sec:introduction}

Data provenance provides an explicit intermediate program representation recording control and data dependencies for a program execution~\cite{pdg-pingali}.  proved to be one of the important abstractions in program analysis as the concept is used for a wide range of workflows; including, program debugging, compiler optimizations, data provenance, incremental computation, program slicing, dynamic flow information control and tracking,  etc.


\if 0
Multithreaded programs are notoriously difficult to debug. This difficulty arises from the fact that multithreaded programs are inherently non-deterministic. Consequently, threads accessing the shared-memory region with different inter-leavings may lead to undesirable concurrency bugs, like program crash or data corruption. 


Currently, debugging techniques rely on examining memory state during the program execution or by analyzing core dumps after the program crashes. These techniques mainly target ``what" is the state of the program without revealing much about ``why" is it the state of the program like that. We can aid the developers to better understand the failed execution by augmenting the existing debugging techniques with the lineage information of the memory state or ``why"-provenance or simply data-provenance.

 \fi
%Many existing systems provide support for data provenance; however,
%most target sequential programs (detailed in $\S$~\ref{sec:related}),
%while others that do support parallelism require a new language with a restrictive programming model. Furthermore, the existing  provenance systems for parallel programs rely on manual annotations using a new type system. Thereby, limiting their wide-spread adoption.



In this paper, we propose an OS-based approach to data provenance for multithreaded programs. More specifically, we have two main design goals: (1) To support unmodified shared-memory multithreaded programs with the full range of synchronization primitives in the {\tt POSIX} API; (2) To achieve low overheads by designing the underlying provenance algorithm to be  {\em parallel} as well that does not limit the available application parallelism.


To achieve these goals, we present \projecttitle, a threading library for data provenance. To run a program using \projecttitle,  the user just needs to preload the \projecttitle library  by using the environment variable {\tt LD\_PRELOAD} or {\tt -rdynamic} flag, and then, run the program as usual. Thus, enabling existing binaries to benefit from our approach. 


Our approach is based on recording the data and control dependencies in a computation by constructing a Concurrent Provenance Graph (CPG). The CPG tracks the input data to a program, all sub-computations (a sub-computation is a unit of the computation), the data flow between sub-computations, and intra- and inter-thread control flow of the multithreaded execution.


Overall, this paper makes the following contributions:
\begin{itemize}

\item We present a parallel algorithm for data provenance for multithreaded programs that records intra- and inter-thread control and data dependencies using a Concurrent Provenance Graph (CPG) (\secref{algorithms}).

\item We implemented our algorithm as a dynamically linkable shared library, which we call \projecttitle, leveraging MMU-assisted memory tracking, process-level isolation, and recently released \intelpt ISA extensions.  The \projecttitle library can be loaded and linked at run-time as a replacement to the \pthreads library, without any recompilation  of the application code (\secref{implementation}).

\item  We  empirically demonstrate  the effectiveness of \projecttitle by applying it to applications of standard multithreaded benchmark suites (PARSEC~\cite{parsec} and Phoneix~\cite{phoenix}). Our experiments show that \projecttitle~incurs reasonable overhead for a majority of applications (\secref{evaluation}). 

\end{itemize}

\projecttitle is an active open-source project, and the library is publicly available to the research community. We believe that the CPG abstraction exported by \projecttitle can be used to support of a wide-range of workflows in dependability and security, as discussed in %$$~\ref{sec:discussion}.
