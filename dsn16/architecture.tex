\section{Architecture}
\label{sec:introduction}

To instrument an application we use an execution wrapper. This wrapper instructs
the runtime linker to load our library tthread by setting \emph{LD\_PRELOAD}. It
also prepares a file, which is later on used by tthread to log the thread
schedule and data dependence graph during execution. To obtain control flow, we
use an new Intel ISA Extension, called Processor Trace (PT). In Linux this
processor feature is exposed to userland as a Perfomance Measuring Unit (PMU) in
the perf event interface. The Perf interface takes a process id and returns a
file descriptor. The file descriptor points to data, which is supposed to be
mapped to memory using mmap(2) syscall. At offset 0 of this memory a header
struct named \emph{perf\_event\_mmap\_page} is located.
With the offset of a ring buffer called \emph{AUX area}. PT logs the execution
of process as a series of packets here, which denotes branches taken.
The size of this \emph{AUX area} can be controlled by \emph{perf\_event\_mmap\_page}.

When the application is launched with libtthread loaded, a unix socket is passed
along to the application which is referenced in environment variables.
Libtthread will use this socket to send a pipe and its process id (PID) back.
Once the application wrapper has registered the trace in perf, it will send a
reponse on the passed pipe to allow the program to continue its execution.
Because of libtthread's variant of \emph{pthread\_create()}, a new processes
will be created instead of a threads. So this process will be repeated, whenever
a new "`thread"' is created to adjust the PID filter of perf.

The events gathered by perf, are then processed by Intel Processor Trace Decoder
Library (libipt). To be able to reconstruct execution flow with all
instructions executed, it needs the process image to be reconstructed. Therefor
all as mapped files, marked as executable and referenced in /proc/<pid>/maps are
given to libipt.

After program execution has finished, both pt trace and log of libtthread have
to be merged. This is done using the backtrace information captured in
libtthread, which stores its callees whenever a new thunk is started or memory
access has been intercepted by the MMU.
