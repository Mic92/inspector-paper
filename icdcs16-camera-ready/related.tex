\section{Related Work}
\label{sec:related}





Data provenance is a well-studied concept because of it's wide applicability in different complex computer systems. Next, we review the related work from different domains.






\myparagraph{Database systems} Provenance has been shown to be important in databases for materialized views, probabilistic databases, data integration, and curated databases (see a survey paper for more details~\cite{provenance-database-tutorial}). Almost, all existing provenance work in databases leverage the explicit database schema and structured layout of the input records in tables to build the provenance graph; whereas, \projecttitle does not assume any structured layout of the input data.


 
\myparagraph{``Big Data" analytics} Data provenance is being increasingly used in ``big data"  processing for  debugging complex workflows~\cite{nova, conductor-nsdi-2012, conductor-ladis-2010, conductor-podc-2010}, and also for incremental computation~\cite{incoop, slider, incoop-hotcloud, incApprox, contraction-tree, shredder, Bhatotia15}.  In particular, these systems construct the provenance graph based on the data-flow graph generated from the data-parallel programming model. 
Instead of relying on the constrained task-based programming model,  \projecttitle derives the graph automatically for shared-memory multithreaded programs.


\myparagraph{Distributed and network systems} Many distributed and network systems propose provenance techniques for tracing the  execution of distributed protocols to provide accountability, fault detection, forensics, verifiability, network debugging, negative provenance~\cite{ wu-2014-negative-provenance, snp, dtap}. 
These systems leverage the semantics of distributed protocols to derive a state-machine, and capture the lineage information by manually modifying the state-machine. Instead, we do not require any protocol-specific state-machine. Albeit, we currently do not support distributed systems.




\myparagraph{Storage systems} Storage systems, such as PASS~\cite{pass-atc}, supporting provenance collect meta-data of newly created objects in the system (via the OS support), 
and  maintain their lineage information such as the chain of ownership and the transformations performed on objects. In contrast to PASS that tracks objects in storage systems,  our focus is on tracing the lineage of shared-memory accesses in multithreaded programs at the granularity of memory pages. Like PASS, we also rely on the OS support for tracking of memory pages.


\myparagraph{Memory tracing} Our approach is complementary to numerous run-time~\cite{memtrace} and compile-time~\cite{cgo-compiler-provenance} tools that allow fine-grained byte-level memory read and writes made by threads. In contrast, our tool makes a trade-off of memory tracking at the granularity of memory pages, and uses a combination of OS support and the new ISA extensions to track the data flow for the entire program. 


\myparagraph{Operating systems} Linux Provenance Module (LPM)~\cite{lpm} provides OS support to collect system-wide provenance. In contrast to LPM, \projecttitle is a user-space solution and does not require any modifications to the underlying OS. Secondly, unlike LPM, which collects provenance at the granularity of a process, we collect data provenance at a finer granularity of a thread.  On the other hand, LPM benefits from the integrated OS approach to secure the provenance information. 

\myparagraph{Programming languages} Programming languages researchers develop language-based provenance approaches relying on a new language with special data-types. These language-based approaches derive the provenance graph using techniques such as self-adjusting computation~\cite{Acar05}. In contrast, our work supports existing programs without relying on any language-level support or a new type system.



